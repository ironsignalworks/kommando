<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Fog Of War — Real-Time Caverns v0.5.1 (Sprites)</title>
<link rel="icon" href="/favicon.ico">
<link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
<style>
  :root{ --bg:#000; --ink:#e4e7ea; --hud:#0a0d10; --accent:#7efc6b; --danger:#ff5050; --hudBorder:#1a1f25; }
  html,body{height:100%}
  body{margin:0; background:var(--bg); color:var(--ink); font-family:'VT323', ui-monospace, Menlo, Consolas, monospace; overflow:hidden;}

  .app{display:grid; grid-template-rows: 1fr min(10vh, 110px); height:100vh; width:100vw; padding:8px; box-sizing:border-box; gap:8px; justify-items:center; align-content:center;}
  .view{position:relative; width:min(100%, 960px); height:100%; background:#050607; border:1px solid #111; border-radius:10px; overflow:hidden; margin:0 auto; box-sizing:border-box; padding-bottom:4px;}
  canvas{display:block; width:100%; height:calc(100% - 4px); image-rendering:pixelated; box-sizing:border-box}

  .hud-bottom{display:flex; align-items:center; gap:12px; padding:8px 14px; background:linear-gradient(180deg, rgba(7,11,15,.98), rgba(6,9,13,.96)); border:1px solid var(--hudBorder); border-radius:10px; width:min(100%, 960px); margin:0 auto; box-sizing:border-box; overflow:hidden; font-size:15px;}
  .hud-bottom *{font-family:'VT323', ui-monospace, Menlo, Consolas, monospace;}
  .logo{font-family:'Share Tech Mono',ui-monospace,monospace !important; font-size:3px; line-height:3px; letter-spacing:0; white-space:pre; display:block; color:var(--ink); opacity:.9; margin:0 8px 0 0; max-width:100%; overflow:hidden;}
  .hud-col{display:flex; flex-direction:column; justify-content:center; gap:6px; min-width:0;}
  .hud-row{display:flex; align-items:center; gap:8px; white-space:nowrap; min-width:0; flex-wrap:nowrap;}
  .tag{padding:2px 8px; border:1px solid #222; border-radius:999px; font-size:14px; opacity:.9}
  .meter{flex:1 1 150px; min-width:120px; max-width:200px; height:10px; background:#111; border:1px solid #1e2630; border-radius:999px; overflow:hidden}
  .meter>i{display:block; height:100%; width:100%; background:linear-gradient(90deg,#ff3c3c,#ff9f3c)}
  .sep{width:1px; align-self:stretch; background:#1c222b; margin:0 6px}
  .kbd{background:#0e1217; border:1px solid #1b2330; padding:2px 6px; border-radius:6px; font-size:14px}
  .hud-box{display:flex; flex-direction:column; gap:6px; padding:0; background:transparent; border:0; border-radius:0; flex:0 1 auto; min-width:auto; max-width:none;}
  .hud-col.stats{flex:1 1 auto;}
  #levelName{display:inline-block; font-size:15px; max-width:240px; white-space:normal; overflow-wrap:break-word; line-height:1.2;}
  .hud-row.level-row{align-items:flex-start;}
  .hud-row span{white-space:nowrap;}
  .hud-controls{opacity:.85; gap:6px;}
  .hud-controls .separator{opacity:.7;}

  @media (max-width: 1024px){
    .logo{display:none}
    .hud-bottom{gap:10px; padding:6px 8px}
    .meter{width:120px; height:9px}
    .tag{font-size:12px}
    .kbd{font-size:12px}
  }
  @media (max-width: 720px){
    .app{grid-template-rows: 1fr min(15vh, 120px)}
    .hud-bottom{flex-wrap:wrap; justify-content:space-between}
    .hud-col{gap:4px}
    .meter{width:100px; height:8px}
    #levelName{max-width:100%}
  }
  @media (max-width: 480px){
    .hud-bottom{gap:8px}
    .hud-row{gap:6px}
    .meter{width:92px; height:8px}
  }
</style>
</head>
<body>
  <div class="app">
    <div class="view">
      <canvas id="screen" width="960" height="576"></canvas>
    </div>
    <div class="hud-bottom">
      <pre class="logo">█████   ████    ███████    ██████   ██████ ██████   ██████   █████████   ██████   █████ ██████████      ███████
▒▒███   ███▒   ███▒▒▒▒▒███ ▒▒██████ ██████ ▒▒██████ ██████   ███▒▒▒▒▒███ ▒▒██████ ▒▒███ ▒▒███▒▒▒▒███   ███▒▒▒▒▒███
 ▒███  ███    ███     ▒▒███ ▒███▒█████▒███  ▒███▒█████▒███  ▒███    ▒███  ▒███▒███ ▒███  ▒███   ▒▒███ ███     ▒▒███
 ▒███████    ▒███      ▒███ ▒███▒▒███ ▒███  ▒███▒▒███ ▒███  ▒███████████  ▒███▒▒███▒███  ▒███    ▒███▒███      ▒███
 ▒███▒▒███   ▒███      ▒███ ▒███ ▒▒▒  ▒███  ▒███ ▒▒▒  ▒███  ▒███▒▒▒▒▒███  ▒███ ▒▒██████  ▒███    ▒███▒███      ▒███
 ▒███ ▒▒███  ▒▒███     ███  ▒███      ▒███  ▒███      ▒███  ▒███    ▒███  ▒███  ▒▒█████  ▒███    ███ ▒▒███     ███
 █████ ▒▒████ ▒▒▒███████▒   █████     █████ █████     █████ █████   █████ █████  ▒▒█████ ██████████   ▒▒▒███████▒
▒▒▒▒▒   ▒▒▒▒    ▒▒▒▒▒▒▒    ▒▒▒▒▒     ▒▒▒▒▒ ▒▒▒▒▒     ▒▒▒▒▒ ▒▒▒▒▒   ▒▒▒▒▒ ▒▒▒▒▒    ▒▒▒▒▒ ▒▒▒▒▒▒▒▒▒▒      ▒▒▒▒▒▒▒</pre>
      <div class="sep"></div>
      <div class="hud-col">
        <div class="hud-row"><span style="font-size:18px">Fog Of War</span><span class="tag" id="build">v0.5.1</span></div>
        <div class="hud-row level-row"><span>Level:</span><span id="levelName">&#8212;</span></div>
      </div>
      <div class="sep"></div>
      <div class="hud-col stats">
        <div class="hud-row"><span>Sanity</span><div class="meter"><i id="sanityBar" style="width:100%"></i></div><span id="sanityPct">100%</span></div>
        <div class="hud-row"><span>Fragments</span><span id="diamonds">0/0</span><span style="opacity:.6">|</span><span>Exit</span><span id="exitState">Locked</span></div>
      </div>
      <div class="sep"></div>
      <div class="hud-col controls">
      <div class="hud-row hud-controls"><span>Move</span><span class="kbd">WASD</span><span class="separator">/</span><span>Arrow Keys</span><span class="separator">•</span><span>Shoot</span><span class="kbd">Space</span></div></div>
    </div>
  </div>

<script>
/**********************
 * CONFIG & CONSTANTS *
 **********************/
const TILE_W = 16;
const TILE_H = 18;
const GRID_W = 60;
const GRID_H = 30;
const WORLD_W = GRID_W * TILE_W;
const WORLD_H = GRID_H * TILE_H;

// realtime timing (ms)
const MOVE_COOLDOWN   = 70;
const ENEMY_COOLDOWN  = 130;
const BULLET_COOLDOWN = 140;
const BULLET_SPEED    = 0.55;
const SANITY_DRAIN_PS = 3;

// earthy brownish tile colors (kept for tint helpers / legacy)
const COLOR_WALL = '#8a4b3a';
const COLOR_WALL_DARK = '#51302a';
const COLOR_FLOOR_LIT = '#3c2a28';
const COLOR_FLOOR_SEEN = '#2a1f1d';

const Glyphs = {
  floor:   { ch:' ', fg:COLOR_FLOOR_LIT, bg:null },
  wall:    { ch:'█', fg:COLOR_WALL, bg:null },
  jack:    { ch:'@', fg:'#66aaff', bg:null },
  enemy:   { ch:'●', fg:'#ff3c3c', bg:null },
  bullet:  { ch:'*', fg:'#ffd36e', bg:null },
  diamond: { ch:'♦', fg:'#00ff66', bg:null },
  exit:    { ch:'>', fg:'#c7d2da', bg:null },
  palm:    { ch:'♣', fg:'#37d065', bg:null },
  mine:    { ch:'×', fg:'#ffd94d', bg:null },
};

const PALETTES = {
  reality:   { name:'Reality',   tint:[0.70,0.85,1.30], bg:'#0c131d', lampColor:'rgba(150,180,230,0.32)', rainColor:'rgba(135,165,215,0.6)', floorTint:'rgba(36,58,88,0.32)', wallTint:'rgba(90,110,140,0.28)' },
  jungle:    { name:'Flashback', tint:[0.65,1.22,0.70], bg:'#041407', fogColor:'rgba(14,60,28,0.55)', flash:'#ffd94d', tracer:'#ffe871', floorTint:'rgba(26,82,44,0.35)', wallTint:'rgba(52,120,68,0.32)' },
  paranoia:  { name:'Paranoia',  tint:[1.35,0.52,0.52], bg:'#1b0404', bleed:'#5c0909', flash:'#7a0000', floorTint:'rgba(110,26,26,0.32)', wallTint:'rgba(140,30,30,0.38)' },
  psychosis: { name:'Psychosis', tint:[1.0,1.0,1.0], bg:'#050505', flash:'#aa0000', mode:'bw', floorTint:'rgba(210,210,210,0.18)', wallTint:'rgba(80,80,80,0.20)' },
  collapse:  { name:'Collapse',  tint:[1.12,1.04,1.10], bg:'#040404', flash:'#b8a37a', static:'#d0d0d0', floorTint:'rgba(56,54,60,0.28)', wallTint:'rgba(92,82,70,0.30)' },
};

const LEVELS = [
  { id:1, key:'reality',   name:'WELCOME HOME',           enemies:1,  diamonds:1,  mines:0 },
  { id:2, key:'jungle',    name:'FLASHBACK',              enemies:1,  diamonds:1, mines:0,
    complexity:{ rooms:14, connectors:5, carveSeeds:3, carveStepMul:1.6 } },
  { id:3, key:'paranoia',  name:'TARGETS OF OPPORTUNITY', enemies:1,  diamonds:1, mines:0,
    complexity:{ rooms:12, connectors:4, carveSeeds:2, carveStepMul:1.25 } },
  { id:4, key:'psychosis', name:'THE RAID',               enemies:1, diamonds:1, mines:1,
    complexity:{ rooms:13, connectors:5, carveSeeds:3, carveStepMul:1.35 } },
  { id:5, key:'collapse',  name:'EXTRACTION',             enemies:1, diamonds:1, mines:1,
    complexity:{ rooms:15, connectors:6, carveSeeds:3, carveStepMul:1.5 } },
];

// ASCII assets (kept for game over screen)
const ASCII_RIP = [
"⠀⠀⠀⠀⣀⠤⠔⠒⠒⠒⠒⠒⠒⠒⠦⢄⠀⠀⠀⠀⠀",
"⠀⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠑⢄⠀⠀",
"⢀⠎⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢣⠀",
"⢸⠀⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢢⠈⡇",
"⢸⠀⣇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡼⠀⡇",
"⠘⡆⢸⠀⢀⣀⣤⣄⡀⠀⠀⠀⢀⣤⣤⣄⡀⠀⡇⠀⠀",
"⠀⠘⣾⠀⣿⣿⣿⣿⣿⠀⠀⠀⣿⣿⣿⣿⣿⠀⡇⠀⠀",
"⠀⠀⣿⠀⠙⢿⣿⠿⠃⢠⢠⡀⠙⠿⣿⠿⠃⠀⡇⠀⠀",
"⠀⠀⠘⣄⡀⠀⠀⠀⢠⣿⢸⣿⠀⠀⠀⠀⠀⣠⠇⠀⠀",
"⠀⠀⠀⠀⡏⢷⡄⠀⠘⠟⠈⠿⠁⠀⢠⡞⡹⠁⠀⠀⠀",
"⠀⠀⠀⠀⢹⠸⠘⢢⢠⠤⠤⡤⡄⢰⢡⠁⡇⠀⠀⠀⠀",
"⠀⠀⠀⠀⢸⠀⠣⣹⢸⠒⠒⡗⡇⣩⠌⢀⡇⠀⠀⠀⠀",
"⠀⠀⠀⠀⠈⢧⡀⠀⠉⠉⠉⠉⠁⠀⣀⠜⠀⠀⠀⠀⠀",
"⠀⠀⠀⠀⠀⠀⠉⠓⠢⠤⠤⠤⠔⠊⠁⠀⠀⠀⠀⠀⠀"
];
const ASCII_GAMEOVER = [
" ░▒▓██████▓▒░ ░▒▓██████▓▒░░▒▓██████████████▓▒░░▒▓████████▓▒░       ░▒▓██████▓▒░░▒▓█▓▒░░▒▓█▓▒░▒▓████████▓▒░▒▓███████▓▒░  ",
"░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░             ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░ ",
"░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░             ░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒▒▓█▓▒░░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░ ",
"░▒▓█▓▒▒▓███▓▒░▒▓████████▓▒░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░▒▓██████▓▒░        ░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒▒▓█▓▒░░▒▓██████▓▒░ ░▒▓███████▓▒░  ",
"░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░             ░▒▓█▓▒░░▒▓█▓▒░ ░▒▓█▓▓█▓▒░ ░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░ ",
"░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░             ░▒▓█▓▒░░▒▓█▓▒░ ░▒▓█▓▓█▓▒░ ░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░ ",
" ░▒▓██████▓▒░░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░▒▓████████▓▒░       ░▒▓██████▓▒░   ░▒▓██▓▒░  ░▒▓████████▓▒░▒▓█▓▒░░▒▓█▓▒░ ",
"                                                                                                                        ",
"                                                                                                                        "
];

/**********************
 * UTILS & LOG
 **********************/
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const rand =(n)=>Math.floor(Math.random()*n);
const choice=(arr)=>arr[rand(arr.length)];
const manhattan=(x1,y1,x2,y2)=>Math.abs(x1-x2)+Math.abs(y1-y2);
function log(msg){ try{ console.log('[LOG]', msg);}catch(_){} }

/**********************
 * VISUAL HELPERS (legacy)
 **********************/
function wallGlyph(x,y,key){
  const r=(x*3+y*5)%8;
  if(key==='jungle') return (r<3)?'▓':(r<6)?'▒':'█';
  return (r<2)?'█':(r<4)?'▓':'▒';
}

/**********************
 * FOV (shadowcasting)
 **********************/
function computeFOV(map, ox, oy, radius=12){
  const vis=new Set(); vis.add(oy*map.w+ox);
  function castRow(row,start,end,xx,xy,yx,yy){
    if(start<end) return; let r=row;
    while(r<=radius){
      let dx=-r-1, dy=-r, blocked=false;
      while(dx<=0){
        dx++;
        const X=ox+dx*xx+dy*xy, Y=oy+dx*yx+dy*yy;
        const ldx=-dx, ldy=dy; const lSlope=(ldx-0.5)/(ldy+0.5), rSlope=(ldx+0.5)/(ldy-0.5);
        if(!(X>=0&&Y>=0&&X<map.w&&Y<map.h) || start<rSlope) { continue; }
        if(end>lSlope){ break; }
        const idx=Y*map.w+X; if((dx*dx+dy*dy)<=radius*radius){ vis.add(idx); }
        if(map.isWall(X,Y)){
          if(!blocked){ blocked=true; start=rSlope; castRow(r+1,start,end,xx,xy,yx,yy); }
          else { end=lSlope; }
        } else if(blocked){ blocked=false; start=rSlope; }
      }
      r++;
    }
  }
  castRow(1,1.0,0.0, 1,0,0,1); castRow(1,1.0,0.0, 1,0,0,-1); castRow(1,1.0,0.0,-1,0,0,1); castRow(1,1.0,0.0,-1,0,0,-1);
  castRow(1,1.0,0.0, 0,1,1,0); castRow(1,1.0,0.0, 0,1,-1,0); castRow(1,1.0,0.0, 0,-1,1,0); castRow(1,1.0,0.0, 0,-1,-1,0);
  if(radius>0 && vis.size===1){
    const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
    for(const [dx,dy] of dirs){
      const nx=ox+dx, ny=oy+dy;
      if(nx>=0 && ny>=0 && nx<map.w && ny<map.h && !(map.isWall && map.isWall(nx,ny))){
        vis.add(ny*map.w+nx);
      }
    }
  }
  return vis;
}

/**********************
 * WORLD & MAP GEN
 **********************/
class RNG{constructor(seed=Date.now()%1e9){this.s=seed>>>0;} next(){let x=this.s; x^=x<<13; x^=x>>>17; x^=x<<5; this.s=x>>>0; return this.s/0xFFFFFFFF;} int(n){return Math.floor(this.next()*n);} }

class Map{
  constructor(w,h){
    const W=Math.max(5,Number.isFinite(w)?Math.floor(w):0);
    const H=Math.max(5,Number.isFinite(h)?Math.floor(h):0);
    this.w=W; this.h=H; this.cells=new Array(W*H).fill(1);
  }
  idx(x,y){return y*this.w+x;} inb(x,y){return x>=0&&y>=0&&x<this.w&&y<this.h;} isWall(x,y){return this.cells[this.idx(x,y)]===1;} carve(x,y){this.cells[this.idx(x,y)]=0;}
  carveRect(x0,y0,x1,y1){ const xA=Math.max(1,Math.min(x0,x1)), xB=Math.min(this.w-2,Math.max(x0,x1)); const yA=Math.max(1,Math.min(y0,y1)), yB=Math.min(this.h-2,Math.max(y0,y1)); for(let y=yA;y<=yB;y++) for(let x=xA;x<=xB;x++) this.carve(x,y); }

  generate(seed, opts={}){
    const rng=new RNG(seed);
    const w=this.w,h=this.h; const id=(x,y)=>y*w+x; const cells=this.cells;
    for(let i=0;i<cells.length;i++) cells[i]=1;

    const targetRooms = opts.rooms ?? 10;
    const extraConnect = opts.connectors ?? 2;
    const carveSeeds = opts.carveSeeds ?? (1 + rand(2));
    const carveStepMul = opts.carveStepMul ?? 1.0;

    const rooms=[]; let attempts=0;
    while(rooms.length<targetRooms && attempts<targetRooms*40){
      attempts++;
      const large = Math.random()<0.45;
      const rw = large ? 10+rand(8) : 4+rand(4);
      const rh = large ?  6+rand(5) : 3+rand(3);
      const rx = 2+rand(Math.max(2,w-rw-4));
      const ry = 2+rand(Math.max(2,h-rh-4));
      const rect={x:rx,y:ry,w:rw,h:rh,cx:rx+Math.floor(rw/2),cy:ry+Math.floor(rh/2)};
      let overlaps=false; for(const r of rooms){ if(!(rect.x+rect.w+1<r.x || r.x+r.w+1<rect.x || rect.y+rect.h+1<r.y || r.y+r.h+1<rect.y)){ overlaps=true; break; } }
      if(!overlaps){ rooms.push(rect); this.carveRect(rect.x,rect.y,rect.x+rect.w,rect.y+rect.h); }
    }

    const centers=rooms.map(r=>[r.cx,r.cy]);
    function digL(ax,ay,bx,by){ let x=ax,y=ay; while(x!==bx){ x += (bx>x)?1:-1; cells[id(x,y)]=0; } while(y!==by){ y += (by>y)?1:-1; cells[id(x,y)]=0; } cells[id(bx,by)]=0; }
    if(centers.length){
      const N=centers.length; const used=new Array(N).fill(false); used[0]=true; let edges=0;
      while(edges<N-1){
        let bestA=-1,bestB=-1,bestD=1e9;
        for(let a=0;a<N;a++) if(used[a]) for(let b=0;b<N;b++) if(!used[b]){
          const dx=centers[a][0]-centers[b][0], dy=centers[a][1]-centers[b][1];
          const d=dx*dx+dy*dy; if(d<bestD){ bestD=d; bestA=a; bestB=b; }
        }
        if(bestB===-1) break; used[bestB]=true; edges++;
        digL(centers[bestA][0],centers[bestA][1], centers[bestB][0],centers[bestB][1]);
      }
      for(let k=0;k<extraConnect;k++){ const a=rand(N), b=rand(N); if(a!==b) digL(centers[a][0],centers[a][1], centers[b][0],centers[b][1]); }
    }

    // sparse carve in odd grid
    const odd = v => (v%2===1);
    const inOddGrid=(x,y)=> x>1&&y>1&&x<w-2&&y<h-2&&odd(x)&&odd(y);
    const dirs=[[2,0],[-2,0],[0,2],[0,-2]];
    function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [a[i],a[j]]=[a[j],a[i]]; } return a; }

    function carveSparseFrom(sx,sy,stepsMax){
      let steps=0; const st=[[sx,sy]]; cells[id(sx,sy)]=0;
      while(st.length && steps<stepsMax){
        const [cx,cy]=st[st.length-1];
        let moved=false; const order=shuffle(dirs.slice());
        for(const [dx,dy] of order){
          const nx=cx+dx, ny=cy+dy;
          if(inOddGrid(nx,ny) && cells[id(nx,ny)]===1){
            cells[id(cx+dx/2,cy+dy/2)]=0; cells[id(nx,ny)]=0; st.push([nx,ny]); moved=true; steps++; break;
          }
        }
        if(!moved) st.pop();
      }
    }
    const seeds = carveSeeds;
    for(let s=0;s<seeds;s++){
      const sx= 3 + rand(Math.max(1, Math.floor((w-6)/2)))*2;
      const sy= 3 + rand(Math.max(1, Math.floor((h-6)/2)))*2;
      const stepsMax = Math.floor((w*h)*0.008 * carveStepMul);
      if(inOddGrid(sx,sy)) carveSparseFrom(sx,sy,stepsMax);
    }

    // keep largest region
    const reg=new Array(w*h).fill(-1); let rid=0; const areas=[];
    for(let y=1;y<h-1;y++) for(let x=1;x<w-1;x++) if(cells[id(x,y)]===0 && reg[id(x,y)]===-1){
      const q=[[x,y]]; reg[id(x,y)]=rid; let a=0;
      while(q.length){
        const [qx,qy]=q.pop(); a++;
        for(const [dx,dy] of [[1,0],[-1,0],[0,1],[0,-1]]){
          const nx=qx+dx, ny=qy+dy, i=id(nx,ny);
          if(nx>0&&ny>0&&nx<w-1&&ny<h-1 && cells[i]===0 && reg[i]===-1){ reg[i]=rid; q.push([nx,ny]); }
        }
      }
      areas[rid]=a; rid++;
    }
    const best=areas.length?areas.indexOf(Math.max(...areas)):-1; if(best>=0){ for(let y=1;y<h-1;y++) for(let x=1;x<w-1;x++) if(reg[id(x,y)]!==best) cells[id(x,y)]=1; }

    // widen if too cramped
    const openCount=()=>cells.reduce((a,c)=>a+(c===0?1:0),0); const floors=openCount(); const min=Math.floor(w*h*0.20);
    if(floors<min){ for(let y=2;y<h-2;y++) for(let x=2;x<w-2;x++){ if(cells[id(x,y)]===1){ let n=0; if(cells[id(x+1,y)]===0)n++; if(cells[id(x-1,y)]===0)n++; if(cells[id(x,y+1)]===0)n++; if(cells[id(x,y-1)]===0)n++; if(n>=3) cells[id(x,y)]=0; } } }

    // hard borders
    for(let x=0;x<w;x++){ cells[id(x,0)]=1; cells[id(x,h-1)]=1; }
    for(let y=0;y<h;y++){ cells[id(0,y)]=1; cells[id(w-1,y)]=1; }
  }
}

/**********************
 * SPRITE FACTORY (runtime-generated lego-ish sprites)
 **********************/
const SPR = {}; // sprite atlas: name -> offscreen canvas

function makeSprite(w, h, drawFn, scale = 1){
  const c = document.createElement('canvas');
  c.width = Math.max(1, w * scale);
  c.height = Math.max(1, h * scale);
  const g = c.getContext('2d');
  g.imageSmoothingEnabled = false;
  g.save(); g.scale(scale, scale); drawFn(g); g.restore();
  return c;
}
function px(g, x, y, color){ g.fillStyle=color; g.fillRect(x, y, 1, 1); }
function mirrorHalf(g, halfW, h, paintHalf){
  paintHalf(+1);
  g.save(); g.translate(halfW*2,0); g.scale(-1,1); paintHalf(-1); g.restore();
}
function buildSprites(){
  const u = 12;

  // Player — commando
  SPR.commando = makeSprite(10, u, (g)=>{
    const skin = '#f1c07a', cloth='#203a63', cloth2='#2b4b7a', strap='#5a3a1f', visor='#8ad8ff', dk='#0e1c33';
    px(g,4,0, dk); px(g,5,0, dk);
    px(g,3,1, dk); px(g,4,1, cloth2); px(g,5,1, cloth2); px(g,6,1, dk);
    px(g,3,2, cloth2); px(g,4,2, visor); px(g,5,2, visor); px(g,6,2, cloth2);
    px(g,4,3, skin); px(g,5,3, skin);
    for(let y=4;y<8;y++){ for(let x=3;x<=6;x++) px(g,x,y, cloth); }
    px(g,3,5,'#2f567f'); px(g,6,6,'#2f567f'); px(g,4,7,'#376291');
    px(g,3,4, strap); px(g,6,4, strap);
    px(g,2,5, skin); px(g,7,5, skin);
    px(g,2,6, cloth2); px(g,7,6, cloth2);
    for(let x=3;x<=6;x++) px(g,x,8,'#111820'); px(g,4,8,'#887a3a');
    for(let y=9;y<12;y++){ px(g,4,y, cloth2); px(g,5,y, cloth2); }
    px(g,3,11,'#232323'); px(g,6,11,'#232323');
  });

  // Enemy — red drone
  SPR.enemy = makeSprite(10, u, (g)=>{
    const base='#6e1010', mid='#991b1b', hi='#ff3c3c', eye='#ffc04d';
    mirrorHalf(g,5,u,()=>{
      px(g,2,0, base); px(g,3,0, base);
      px(g,1,1, base); px(g,2,1, mid); px(g,3,1, mid); px(g,4,1, base);
      px(g,1,2, mid); px(g,2,2, hi);  px(g,3,2, hi);  px(g,4,2, mid);
      px(g,2,3, mid); px(g,3,3, eye);
    });
    for(let x=2;x<=7;x++) px(g,x,4, mid);
    px(g,2,6, base); px(g,7,6, base);
  });

  // Ghost — paranoia
  SPR.ghost = makeSprite(10, u, (g)=>{
    const mist='#c53a53', glow='#ff6e8b', edge='#5b0f1e';
    mirrorHalf(g,5,u,()=>{
      px(g,3,1, mist); px(g,2,2, mist); px(g,3,2, glow);
      px(g,3,3, glow); px(g,2,3, mist); px(g,4,3, glow);
    });
    px(g,4,5, glow); px(g,5,6, mist);
    for(let x=2;x<=7;x++) px(g,x,4, edge);
  });

  // Palm
  SPR.palm = makeSprite(10, u, (g)=>{
    const trunk='#6b4a2e', leaf='#37d065', leaf2='#2aa955';
    for(let y=6;y<12;y++) px(g,4,y,trunk);
    px(g,2,5,leaf); px(g,3,4,leaf2); px(g,5,4,leaf2); px(g,6,5,leaf);
    px(g,1,6,leaf); px(g,7,6,leaf);
  });

  // Bullet
  SPR.bullet = makeSprite(4, 4, (g)=>{
    px(g,0,1,'#5c4a1a'); px(g,1,1,'#ffd36e'); px(g,2,1,'#ffd36e'); px(g,3,1,'#fff2b0');
    px(g,2,0,'#ffd36e'); px(g,2,2,'#ffd36e');
  });

  // Diamond
  SPR.diamond = makeSprite(8, 8, (g)=>{
    const a='#00ff66', b='#a6ffd3';
    px(g,3,0,b);
    px(g,2,1,a); px(g,3,1,b); px(g,4,1,a);
    px(g,1,2,a); px(g,2,2,b); px(g,3,2,b); px(g,4,2,b); px(g,5,2,a);
    px(g,2,3,a); px(g,3,3,b); px(g,4,3,a);
    px(g,3,4,a);
  });

  // Exit
  SPR.exit = makeSprite(8, 8, (g)=>{
    const c='#c7d2da';
    for(let y=1;y<7;y++){ px(g,2,y,c); px(g,3,y,c); px(g,4,y,c); }
    px(g,5,1,c); px(g,5,6,c);
  });

  // Floor / Wall tiles
  SPR.floor = makeSprite(16, 16, (g)=>{
    g.fillStyle = '#2f2321'; g.fillRect(0,0,16,16);
    g.globalAlpha = 0.18;
    for(let i=0;i<18;i++){
      g.fillStyle = (Math.random()<0.5)?'#3c2a28':'#2a1f1d';
      g.fillRect((Math.random()*16)|0,(Math.random()*16)|0,1,1);
    }
    g.globalAlpha = 1;
  });
  SPR.wall = makeSprite(16, 16, (g)=>{
    g.fillStyle = '#523329'; g.fillRect(0,0,16,16);
    g.fillStyle = '#8a4b3a';
    for(let y=1;y<16;y+=5){
      for(let x=(y%10?0:3); x<16; x+=6){
        g.fillRect(x, y, 5, 3);
      }
    }
    g.globalAlpha = 0.25;
    for(let i=0;i<12;i++){
      g.fillStyle = (Math.random()<0.5)?'#6a3b30':'#3e2621';
      g.fillRect((Math.random()*16)|0,(Math.random()*16)|0,1,1);
    }
    g.globalAlpha = 1;
  });
}
function drawSprite(ctx, name, x, y, w=TILE_W, h=TILE_H){
  const img = SPR[name];
  if(!img) return;
  const aspect = img.width ? (img.height / img.width) : 1;
  const targetH = Math.min(h, w * aspect);
  const oy = (h - targetH) * 0.5;
  ctx.imageSmoothingEnabled = false;
  ctx.drawImage(img, x, y + oy, w, targetH);
}

/**********************
 * ENTITIES & SYSTEMS
 **********************/
class Entity{ constructor(x,y,t){ this.x=x; this.y=y; this.type=t; this.hp=1; this.cool=0; this.tx=x; this.ty=y; this.fast=false; } }

class Game{
  centerStage(){
    const container = document.querySelector('.view');
    if(!container) return;
    const rect = container.getBoundingClientRect();
    this.canvas.style.maxWidth = rect.width + 'px';
    this.canvas.style.maxHeight = rect.height + 'px';
  }
  fitCanvas(){
    const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    const rect = this.canvas.getBoundingClientRect();
    const w = Math.max(1, Math.floor(rect.width));
    const h = Math.max(1, Math.floor(rect.height));
    this.canvas.width = Math.floor(w * dpr);
    this.canvas.height = Math.floor(h * dpr);
    this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    this.ctx.font = `${TILE_H}px 'VT323', monospace`;
    this.ctx.textBaseline = 'top';
  }
  constructor(){
    this.canvas=document.getElementById('screen');
    this.ctx=this.canvas.getContext('2d');
    this.ctx.font=`${TILE_H}px 'VT323', monospace`;
    this.ctx.textBaseline='top';
    this.levelIndex=0; this.rng=new RNG();
    this.keys=new Set();
    this.last=0; this.lastMove=0; this.lastEnemy=0; this.lastShot=0;
    this.flashT=0; this.flashColor=null; this.glitchT=0;

    // FX
    this.gunfireT = 0;           // L2
    this.enemyInterval = ENEMY_COOLDOWN;

    // L3 paranoia
    this.paranoiaSweepT = 0;
    this.phantoms = [];

    // L4 psychosis
    this.controlInvertT = 0;

    // L5 collapse
    this.trail = [];
    this.collapseTimer = 0;
    this.extractionCountdown = null;

    // misc
    this.sanityMul = 1.0;
    this.levelTicks = 0;
    this.rainSeed = Math.random()*1000;
    this.staticSeed = Math.random()*1000;
    this.state='play';
    this.melt=null;
    this.transitioning = false;

    this.resetLevel();
    this.bindInput();

    this.fitCanvas = this.fitCanvas.bind(this);
    this.fitCanvas();
    this.centerStage();
    window.addEventListener('resize', ()=>{ this.centerStage(); });
    window.addEventListener('resize', this.fitCanvas);
    requestAnimationFrame(this.loop.bind(this));
  }

  resetLevel(){
    const spec=LEVELS[this.levelIndex];
    this.levelTicks = 0;
    this.rainSeed = Math.random()*1000;
    this.staticSeed = Math.random()*1000;

    // Map
    this.map=new Map(GRID_W,GRID_H);
    this.map.generate(this.rng.int(1e9), spec.complexity || {});

    // Player
    let px=1,py=1; do{ px=2+rand(this.map.w-4); py=2+rand(this.map.h-4);} while(this.map.isWall(px,py));
    this.player=new Entity(px,py,'jack');
    this.entities=[this.player];

    // Enemies
    for(let i=0;i<spec.enemies;i++){
      let ex=1,ey=1; do{ ex=rand(this.map.w); ey=rand(this.map.h);} while(this.map.isWall(ex,ey));
      const e=new Entity(ex,ey,'enemy'); this.pickNewPatrol(e);
      if(spec.key==='psychosis' && Math.random()<0.35){ e.fast=true; }
      this.entities.push(e);
    }

    // Diamonds
    this.diamonds=new Set();
    const totalCells = this.map.w * this.map.h;
    let d=0, diamondAttempts=0;
    const diamondTarget = spec.diamonds || 0;
    while(d<diamondTarget && diamondAttempts < totalCells*4){
      diamondAttempts++;
      const dx=rand(this.map.w), dy=rand(this.map.h);
      if(this.map.isWall(dx,dy)) continue;
      const idx=dy*this.map.w+dx;
      if(idx===py*this.map.w+px) continue;
      if(this.diamonds.has(idx)) continue;
      this.diamonds.add(idx); d++;
    }

    // Exit
    let ex=px,ey=py,tries=0; do{ ex=2+rand(this.map.w-4); ey=2+rand(this.map.h-4); tries++; } while((Math.abs(ex-px)+Math.abs(ey-py)<24 || this.map.isWall(ex,ey)) && tries<2000); this.exit=ey*this.map.w+ex;

    if(this.diamonds.size===0 && diamondTarget>0){
      const fallbackOffsets=[[2,0],[-2,0],[0,2],[0,-2],[3,0],[0,3],[-3,0],[0,-3],[4,0],[0,4]];
      for(const [fx,fy] of fallbackOffsets){
        const nx=clamp(px+fx,1,this.map.w-2);
        const ny=clamp(py+fy,1,this.map.h-2);
        const idx=ny*this.map.w+nx;
        if(this.map.isWall(nx,ny) || idx===this.exit) continue;
        this.diamonds.add(idx);
        break;
      }
      if(this.diamonds.size===0){
        const spawnIdx=py*this.map.w+px;
        if(spawnIdx!==this.exit) this.diamonds.add(spawnIdx);
      }
    }
    this.diamondGoal = this.diamonds.size;


    // Bullets & seen
    this.bullets=[]; this.seen=new Set(); this.sanity=100; this.ammo=24; this.lastDir=[1,0];

    // Mines
    this.mines = new Set();
    const wantedMines = spec.mines || 0;
    let placed=0, mineAttempts=0, maxMineAttempts = totalCells * 4;
    while(placed<wantedMines && mineAttempts < maxMineAttempts){
      mineAttempts++;
      const mx = 2+rand(this.map.w-4), my = 2+rand(this.map.h-4);
      const midx = my*this.map.w+mx;
      if(this.map.isWall(mx,my)) continue;
      if(midx===this.exit) continue;
      if(this.diamonds.has(midx)) continue;
      if(mx===px && my===py) continue;
      if(this.entities.some(e=>e.x===mx&&e.y===my)) continue;
      if(this.mines.has(midx)) continue;
      this.mines.add(midx);
      placed++;
    }
    this.mineGoal = placed;

    // Decor
    this.decor = new globalThis.Map();
    const placeDecor = (count, sprite)=>{
      let placed=0, attempts=0, maxAttempts=totalCells*3;
      while(placed<count && attempts<maxAttempts){
        attempts++;
        const x=2+rand(this.map.w-4), y=2+rand(this.map.h-4);
        const i=y*this.map.w+x;
        if(this.map.isWall(x,y)||i===this.exit||this.diamonds.has(i)|| this.mines.has(i) || (x===this.player.x&&y===this.player.y) || this.entities.some(e=>e.x===x&&e.y===y) || this.decor.has(i)) continue;
        this.decor.set(i,sprite); placed++;
      }
    };
    const levelKey=spec.key; if(levelKey==='jungle'||levelKey==='paranoia'){ placeDecor(16,'palm'); }

    // Level specifics
    this.enemyInterval = (spec.key==='jungle') ? Math.max(80, ENEMY_COOLDOWN * 0.75) : ENEMY_COOLDOWN;
    this.gunfireT = 0;
    this.controlInvertT = 0;
    this.trail = [];
    this.collapseTimer = (spec.key==='collapse') ? 900 : 0;
    this.extractionCountdown = null;
    this.sanityMul = (spec.key==='collapse') ? 1.35 : 1.0;

    // L3 phantoms
    if(spec.key==='paranoia'){
      this.phantoms = [];
      const phCount = 10;
      let triesP=0;
      while(this.phantoms.length<phCount && triesP<totalCells){
        triesP++;
        const x=rand(this.map.w), y=rand(this.map.h);
        if(this.map.isWall(x,y)) continue;
        if(this.entities.some(e=>e.x===x&&e.y===y)) continue;
        if(this.diamonds.has(y*this.map.w+x)) continue;
        this.phantoms.push({x,y,phase:Math.random()*Math.PI*2});
      }
    } else {
      this.phantoms = [];
    }

    document.getElementById('levelName').textContent=spec.name;
    this.updateHUD();

    this.state='play'; this.melt=null;
    log(`[LEVEL ${spec.id}] ${spec.name} — Collect all memory fragments (♦) then reach >`);
  }

  startMelt(){
    const w=this.canvas.width, h=this.canvas.height;
    const off=document.createElement('canvas'); off.width=w; off.height=h; const octx=off.getContext('2d');
    octx.drawImage(this.canvas,0,0);
    const colW=2, cols=Math.ceil(w/colW); const offs=new Array(cols).fill(0); const vels=new Array(cols);
    for(let i=0;i<cols;i++){ vels[i]=1.2+Math.random()*2.0; offs[i]=0; }
    this.melt={off:off, colW, cols, offs, vels, done:false, timer:0};
    this.state='melting';
  }

  renderMelt(dt){
    const m=this.melt; if(!m) return;
    const ctx=this.ctx; const w=this.canvas.width, h=this.canvas.height; ctx.clearRect(0,0,w,h);
    for(let i=0;i<m.cols;i++){ m.offs[i]+=m.vels[i]*(dt/16); m.vels[i]+=0.04; }
    for(let i=0;i<m.cols;i++){
      const sx=i*m.colW; const dx=sx; const dy=Math.min(h, m.offs[i]);
      ctx.drawImage(m.off, sx, 0, m.colW, h, dx, dy, m.colW, h);
    }
    ctx.globalAlpha=0.15; ctx.fillStyle='#000'; ctx.fillRect(0,0,w,h); ctx.globalAlpha=1;
    const avg = m.offs.reduce((a,c)=>a+c,0)/m.cols; if(avg>h*1.1){ this.state='gameover'; }
  }

  renderGameOver(){
    const ctx=this.ctx;
    const w=this.canvas.width, h=this.canvas.height;
    ctx.save();
    ctx.setTransform(1,0,0,1,0,0);
    ctx.fillStyle='#000'; ctx.fillRect(0,0,w,h);

    const baseW=960, baseH=576;
    const scale=Math.min(w/baseW,h/baseH);
    const offsetX=(w-baseW*scale)*0.5;
    const offsetY=(h-baseH*scale)*0.5;
    ctx.translate(offsetX,offsetY);
    ctx.scale(scale,scale);
    ctx.textAlign='center'; ctx.textBaseline='top';

    const cx=baseW/2;
    ctx.fillStyle='#ff4040'; ctx.font='14px "VT323", monospace';
    let by=24; for(const line of ASCII_GAMEOVER){ ctx.fillText(line, cx, by); by+=16; }

    ctx.fillStyle='#ff3c3c'; ctx.font='14px "VT323", monospace';
    let y=140; for(const line of ASCII_RIP){ ctx.fillText(line, cx, y); y+=18; }

    ctx.fillStyle = '#ff4040'; ctx.font = '24px "VT323", monospace';
    ctx.fillText('EXTRACTION FAILED', cx, y + 12);

    ctx.fillStyle='#7efc6b'; ctx.font='16px "VT323", monospace';
    ctx.fillText('Press any key to descend again.', cx, baseH-56);

    ctx.restore();
  }

  pickNewPatrol(e){ let tx,ty; do{ tx=rand(this.map.w); ty=rand(this.map.h); } while(this.map.isWall(tx,ty)); e.tx=tx; e.ty=ty; }

  bindInput(){
    window.addEventListener('keydown',(e)=>{
      const k=e.key.toLowerCase();
      if(this.state==='gameover'){
        e.preventDefault();
        this.levelIndex=0; this.resetLevel(); return;
      }
      if(['arrowup','arrowdown','arrowleft','arrowright','w','a','s','d',' '].includes(k)) e.preventDefault();
      this.keys.add(k);
    });
    window.addEventListener('keyup',(e)=>{ this.keys.delete(e.key.toLowerCase()); });
  }

  canStep(x,y){ return this.map.inb(x,y) && !this.map.isWall(x,y); }
  stepEntity(ent,dx,dy){ const nx=ent.x+dx, ny=ent.y+dy; if(this.canStep(nx,ny)){ ent.x=nx; ent.y=ny; return true; } return false; }

  tryMovePlayer(){
    let dx=0,dy=0;
    if(this.keys.has('arrowup')||this.keys.has('w')) dy=-1; else if(this.keys.has('arrowdown')||this.keys.has('s')) dy=1;
    if(this.keys.has('arrowleft')||this.keys.has('a')) dx=-1; else if(this.keys.has('arrowright')||this.keys.has('d')) dx=1;

    if(this.controlInvertT>0){ dx=-dx; dy=-dy; }

    if(dx||dy){
      this.lastDir=[dx,dy];
      if(this.stepEntity(this.player,dx,dy)){
        const idx=this.player.y*this.map.w+this.player.x;
        this.trail.push(idx);
        if(this.trail.length>140) this.trail.shift();
        this.collectAtPlayer();
        this.checkMine();
      }
    }
  }

  shoot(){
    if(this.ammo<=0) return;
    this.ammo--;
    const [dx,dy]=this.lastDir;
    this.bullets.push({x:this.player.x+dx*0.1,y:this.player.y+dy*0.1,dx,dy,life:140});
    this.updateHUD();
  }

  updateBullets(dt){
    const speed=BULLET_SPEED*dt;
    this.bullets=this.bullets.filter(b=>{
      b.x+=b.dx*speed; b.y+=b.dy*speed; b.life--;
      const ix=Math.round(b.x), iy=Math.round(b.y);
      if(!this.map.inb(ix,iy)||this.map.isWall(ix,iy)||b.life<=0) return false;
      const hit=this.entities.find(e=>e.type==='enemy'&&e.x===ix&&e.y===iy);
      if(hit){ hit.hp=0; this.entities=this.entities.filter(e=>e!==hit); this.flashT=12; return false; }
      const midx = iy*this.map.w+ix;
      if(this.mines.has(midx)){ this.mines.delete(midx); this.flashColor=this.currentFlashColor(); this.flashT=10; this.glitchT=Math.max(this.glitchT,8); return false; }
      return true;
    });
  }

  updateEnemies(){
    const spec=LEVELS[this.levelIndex];
    const playerIdx = this.player.y*this.map.w+this.player.x;
    const canopySafe = this.decor && this.decor.has(playerIdx);

    for(const e of this.entities){
      if(e.type!=='enemy') continue;

      if(spec.key==='paranoia'){
        const dist = manhattan(e.x,e.y,this.player.x,this.player.y);
        const aligned = (e.x===this.player.x || e.y===this.player.y);
        let clear = false;
        if(aligned){
          clear = true;
          if(e.x===this.player.x){
            const step = Math.sign(this.player.y - e.y);
            for(let y=e.y+step; y!==this.player.y; y+=step){ if(this.map.isWall(e.x,y)){ clear=false; break; } }
          }else{
            const step = Math.sign(this.player.x - e.x);
            for(let x=e.x+step; x!==this.player.x; x+=step){ if(this.map.isWall(x,e.y)){ clear=false; break; } }
          }
        }
        if(dist<=10 || (aligned && clear)){
          e.tx=this.player.x; e.ty=this.player.y;
        } else if(e.x===e.tx && e.y===e.ty){
          this.pickNewPatrol(e);
        }
      }else{
        if(e.x===e.tx&&e.y===e.ty) this.pickNewPatrol(e);
      }

      const stepOnce = ()=>{
        const dx=Math.sign(e.tx-e.x), dy=Math.sign(e.ty-e.y);
        let moved=false;
        if(Math.random()<0.5){ moved=(dx!==0&&this.stepEntity(e,dx,0)); if(!moved&&dy!==0) moved=this.stepEntity(e,0,dy); }
        else { moved=(dy!==0&&this.stepEntity(e,0,dy)); if(!moved&&dx!==0) moved=this.stepEntity(e,dx,0); }
        if(!moved){
          if(!this.stepEntity(e,(Math.random()<0.5?1:-1),0)) this.stepEntity(e,0,(Math.random()<0.5?1:-1));
          if(Math.random()<0.3) this.pickNewPatrol(e);
        }
      };

      stepOnce();
      if(spec.key==='psychosis' && e.fast) stepOnce();

      if(e.x===this.player.x&&e.y===this.player.y && !canopySafe){ this.onPlayerHit(); }
    }

    if(spec.key==='jungle' && Math.random()<0.05 && this.entities.filter(e=>e.type==='enemy').length < spec.enemies+4){
      let ex=1,ey=1; let tries=0;
      do{ ex=rand(this.map.w); ey=rand(this.map.h); tries++; }
      while((!this.canStep(ex,ey) || (Math.abs(ex-this.player.x)+Math.abs(ey-this.player.y)<18)) && tries<1500);
      const e=new Entity(ex,ey,'enemy'); this.pickNewPatrol(e); this.entities.push(e);
    }
  }

  onPlayerHit(){ log('CAUGHT — GAME OVER'); this.startMelt(); }

  collectAtPlayer(){
    const idx=this.player.y*this.map.w+this.player.x;
    if(this.diamonds.has(idx)){
      this.diamonds.delete(idx);
      this.sanity=clamp(this.sanity+5,0,100);
      this.flashT=12; this.flashColor='#ffd400'; this.glitchT=Math.max(this.glitchT,24);
      this.updateHUD();

      if(this.diamonds.size===0){
        log('All memory fragments collected — Exit unlocked.');
        if(LEVELS[this.levelIndex].key==='collapse' && this.extractionCountdown===null){
          this.extractionCountdown = 20000;
          log('Extraction timer started: 20 seconds.');
        }
      }
    }
  }

  checkMine(){
    const idx=this.player.y*this.map.w+this.player.x;
    if(this.mines.has(idx)){
      this.mines.delete(idx);
      this.flashColor=this.currentFlashColor();
      this.flashT=18;
      this.glitchT=Math.max(this.glitchT,18);
      this.sanity = clamp(this.sanity - 60, 0, 100);
      this.updateHUD();
      if(this.sanity<=0){ log('Mine detonation — sanity collapse'); this.startMelt(); }
    }
  }

  currentFlashColor(){
    const spec=LEVELS[this.levelIndex]; const pal=PALETTES[spec.key];
    return pal.flash || '#aa0000';
  }

  crumbleOne(){
    if(!this.trail.length) return;
    const pickIndex = Math.max(0, this.trail.length - 30);
    const idx = this.trail.splice(pickIndex,1)[0] ?? this.trail.shift();
    if(idx==null) return;
    const x = idx % this.map.w, y = (idx / this.map.w) | 0;

    const pidx=this.player.y*this.map.w+this.player.x;
    if(idx===pidx || idx===this.exit) return;

    this.map.cells[idx]=1;
    this.diamonds.delete(idx);
    this.mines.delete(idx);
    this.decor.delete(idx);

    for(const e of this.entities){
      if(e.type!=='enemy') continue;
      if(e.x===x && e.y===y){
        const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
        for(const [dx,dy] of dirs){ if(this.canStep(x+dx,y+dy)){ e.x+=dx; e.y+=dy; break; } }
      }
    }
    this.flashColor = this.currentFlashColor();
    this.flashT = 8;
  }

  render(){
    const ctx=this.ctx, spec=LEVELS[this.levelIndex], pal=PALETTES[spec.key];
    if(this.state==='melting'){ return; }
    if(this.state==='gameover'){ this.renderGameOver(); return; }

    const viewW = this.canvas.width;
    const viewH = this.canvas.height;
    const scale = Math.min(viewW / WORLD_W, viewH / WORLD_H);
    const offsetX = Math.floor((viewW - WORLD_W * scale) / 2);
    const offsetY = Math.floor((viewH - WORLD_H * scale) / 2);

    ctx.setTransform(1,0,0,1,0,0);
    ctx.imageSmoothingEnabled = false;
    ctx.fillStyle = pal.bg;
    ctx.fillRect(0,0,viewW,viewH);

    ctx.save();
    ctx.translate(offsetX, offsetY);
    ctx.scale(scale, scale);

    let jitterApplied=false;
    // quake jitter (collapse)
    if(spec.key==='collapse' && Math.random()<0.35){
      ctx.save();
      ctx.translate((Math.random()-0.5)*2, (Math.random()-0.5)*2);
      jitterApplied=true;
    }

    // ambient backdrops (unchanged)
    if(spec.key==='reality'){
      const lampCount = Math.max(2, Math.floor(WORLD_W / 260));
      const lampColor = pal.lampColor || 'rgba(145,170,210,0.32)';
      ctx.globalAlpha = 0.18;
      for(let i=0;i<lampCount;i++){
        const lx = (i + 0.5) * WORLD_W / lampCount;
        const lampW = Math.max(28, WORLD_W / lampCount * 0.42);
        const grad = ctx.createLinearGradient(lx, 0, lx, WORLD_H);
        grad.addColorStop(0, 'rgba(60,80,120,0.02)');
        grad.addColorStop(0.25, lampColor);
        grad.addColorStop(0.75, 'rgba(70,90,130,0.08)');
        grad.addColorStop(1, 'rgba(30,40,60,0.02)');
        ctx.fillStyle = grad;
        ctx.fillRect(lx - lampW/2, 0, lampW, WORLD_H);
      }
      ctx.globalAlpha = 1;
    } else if(spec.key==='jungle'){
      ctx.globalAlpha = 0.10;
      const hazePatches = 5;
      for(let i=0;i<hazePatches;i++){
        const px = Math.random()*WORLD_W;
        const py = Math.random()*WORLD_H;
        const radius = 90 + Math.random()*140;
        const grad = ctx.createRadialGradient(px, py, radius*0.15, px, py, radius);
        grad.addColorStop(0, pal.fogColor || 'rgba(18,70,32,0.45)');
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grad;
        ctx.fillRect(px-radius, py-radius, radius*2, radius*2);
      }
      ctx.globalAlpha = 1;
    }

    if(spec.key==='jungle'){
      if(this.gunfireT<=0 && Math.random()<0.04){ this.gunfireT = 4 + rand(6); }
    }

    const vis=computeFOV(this.map,this.player.x,this.player.y,12); for(const i of vis) this.seen.add(i);

    // === SPRITE-BASED TILE RENDER ===
    for(let y=0;y<this.map.h;y++){
      for(let x=0;x<this.map.w;x++){
        const i=y*this.map.w+x, seen=this.seen.has(i), visible=vis.has(i), isWall=this.map.isWall(x,y);
        if(isWall){
          const wallAlpha = visible ? 1 : (seen ? 0.65 : 0.35);
          ctx.globalAlpha = wallAlpha;
          drawSprite(ctx, 'wall', x*TILE_W, y*TILE_H, TILE_W, TILE_W);
          if(pal.wallTint){
            ctx.fillStyle = pal.wallTint;
            ctx.fillRect(x*TILE_W, y*TILE_H, TILE_W, TILE_H);
          }
          ctx.globalAlpha = 1;
        } else {
          const explored = visible || seen;
          const floorAlpha = explored ? 1 : 0.35;
          ctx.globalAlpha = floorAlpha;
          drawSprite(ctx, 'floor', x*TILE_W, y*TILE_H, TILE_W, TILE_W);
          if(pal.floorTint){
            ctx.fillStyle = pal.floorTint;
            ctx.fillRect(x*TILE_W, y*TILE_H, TILE_W, TILE_H);
          }
          ctx.globalAlpha = 1;

          if(this.decor && this.decor.has(i)){
            const deco = this.decor.get(i);
            const spriteName = typeof deco === "string" ? deco : "palm";
            ctx.globalAlpha = explored ? 1 : 0.45;
            drawSprite(ctx, spriteName, x*TILE_W, y*TILE_H, TILE_W, TILE_H);
            ctx.globalAlpha = 1;
          }
          if(this.diamonds.has(i)){
            const diamondAlpha = explored ? 1 : 0.65;
            ctx.globalAlpha = diamondAlpha;
            drawSprite(ctx, 'diamond', x*TILE_W + TILE_W*0.1, y*TILE_H + TILE_H*0.1, TILE_W*0.8, TILE_H*0.8);
            ctx.globalAlpha = 1;
          }
          if(this.mines.has(i) && visible){
            this.drawCharExact(Glyphs.mine.ch, x*TILE_W, y*TILE_H, Glyphs.mine.fg);
          }
          const exitAlpha = explored ? 1 : 0.6;
          if(this.exit===i){
            ctx.globalAlpha = exitAlpha;
            drawSprite(ctx, 'exit', x*TILE_W + TILE_W*0.1, y*TILE_H + TILE_H*0.1, TILE_W*0.8, TILE_H*0.8);
            ctx.globalAlpha = 1;
          }
        }
      }
    }

    // === SPRITE ENTITIES ===
    for(const e of this.entities){
      if(e.type==='jack'){
        if(spec.key==='psychosis' && this.sanity<70){
          ctx.globalAlpha = 0.35;
          drawSprite(ctx, 'commando', (this.player.x-1)*TILE_W, this.player.y*TILE_H, TILE_W, TILE_H);
          drawSprite(ctx, 'commando', (this.player.x+1)*TILE_W, this.player.y*TILE_H, TILE_W, TILE_H);
          ctx.globalAlpha = 1;
        }
        drawSprite(ctx, 'commando', e.x*TILE_W, e.y*TILE_H, TILE_W, TILE_H);
      } else {
        const isGhost = (spec.key==='paranoia');
        drawSprite(ctx, isGhost ? 'ghost' : 'enemy', e.x*TILE_W, e.y*TILE_H, TILE_W, TILE_H);
      }
    }

    // Bullets
    for(const b of this.bullets){
      const ix=Math.round(b.x), iy=Math.round(b.y);
      const i=iy*this.map.w+ix; if(!vis.has(i)) continue;
      drawSprite(ctx, 'bullet', ix*TILE_W + TILE_W*0.25, iy*TILE_H + TILE_H*0.35, TILE_W*0.5, TILE_H*0.3);
    }

    // jungle tracers
    if(spec.key==='jungle' && this.gunfireT>0){
      const n=80; ctx.globalAlpha=0.75;
      for(let k=0;k<n;k++){
        ctx.fillStyle = PALETTES.jungle.tracer || '#ffe871';
        const px=Math.random()*WORLD_W, py=Math.random()*WORLD_H;
        ctx.fillRect(px,py,1,1);
      }
      ctx.globalAlpha=1; this.gunfireT--;
    }

    // paranoia phantoms (keep as '@' echoes for now)
    if(spec.key==='paranoia' && this.sanity<65 && this.phantoms.length){
      ctx.globalAlpha = 0.85;
      for(const ph of this.phantoms){
        const on = (Math.sin((performance.now()/180)+ph.phase) > 0.35);
        if(!on) continue;
        this.drawCharExact('@', ph.x*TILE_W, ph.y*TILE_H, '#cc2244');
      }
      ctx.globalAlpha = 1;
    }

    // hits/glitches
    if(this.glitchT>0){
      const n=120; ctx.globalAlpha=0.9;
      for(let k=0;k<n;k++){ ctx.fillStyle=(Math.random()<0.5)?'#ffd400':'#ffee55'; const px=Math.random()*WORLD_W, py=Math.random()*WORLD_H; ctx.fillRect(px,py,1,1); }
      ctx.globalAlpha=1; this.glitchT--;
    }
    if(this.flashT>0){
      this.flashT--;
      ctx.globalAlpha=0.10; ctx.fillStyle=this.flashColor||pal.flash||'#aa0000'; ctx.fillRect(0,0,WORLD_W,WORLD_H); ctx.globalAlpha=1;
      if(this.flashT===0) this.flashColor=null;
    }

    if(spec.key==='jungle' && Math.random()<0.02){
      ctx.globalAlpha=0.07;
      ctx.fillStyle = PALETTES.jungle.flash || '#ffd94d';
      ctx.fillRect(0,0,WORLD_W,WORLD_H);
      ctx.globalAlpha=1;
    }

    if(spec.key==='reality'){
      ctx.globalAlpha = 0.32;
      ctx.strokeStyle = pal.rainColor || 'rgba(130,160,210,0.55)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      const drops = Math.max(48, Math.floor(WORLD_W / 6));
      const drift = (this.levelTicks || 0) * 0.35 + (this.rainSeed || 0);
      for(let i=0;i<drops;i++){
        const x = Math.random()*WORLD_W;
        const y = (Math.random()*WORLD_H + drift + i*11) % WORLD_H;
        ctx.moveTo(x, y);
        ctx.lineTo(x + 0.6, y + 8);
      }
      ctx.stroke();
      ctx.globalAlpha = 0.22;
      ctx.fillStyle = 'rgba(20,30,40,0.35)';
      ctx.fillRect(0, WORLD_H-6, WORLD_W, 6);
      ctx.globalAlpha = 1;
    }

    if(spec.key==='paranoia'){
      ctx.globalAlpha = 0.18;
      ctx.fillStyle = pal.bleed || '#460505';
      ctx.fillRect(0,0,WORLD_W,12);
      ctx.fillRect(0,WORLD_H-12,WORLD_W,12);
      ctx.globalAlpha = 0.05;
      for(let y=0;y<WORLD_H; y+=3){ ctx.fillStyle='#220000'; ctx.fillRect(0,y,WORLD_W,1); }
      ctx.globalAlpha = 1;
      if(this.sanity<50 && Math.random()<0.03){
        ctx.globalAlpha = 0.06; ctx.fillStyle = '#7a0000'; ctx.fillRect(0,0,WORLD_W,WORLD_H); ctx.globalAlpha = 1;
      }
      const specks = 70; ctx.globalAlpha = 0.35;
      for(let i=0;i<specks;i++){
        ctx.fillStyle = (Math.random()<0.5)?'#441111':'#552222';
        const px=Math.random()*WORLD_W, py=Math.random()*WORLD_H;
        ctx.fillRect(px,py,1,1);
      }
      ctx.globalAlpha = 1;
    }

    if(spec.key==='psychosis'){
      if(this.sanity<75 && Math.random()<0.05){
        ctx.globalAlpha = 0.07; ctx.fillStyle = PALETTES.psychosis.flash; ctx.fillRect(0,0,WORLD_W,WORLD_H); ctx.globalAlpha=1;
      }
      if(Math.random()<0.04){
        ctx.globalAlpha = 0.18;
        const tearX = Math.random()*WORLD_W;
        ctx.fillStyle = 'rgba(160,0,0,0.55)';
        ctx.fillRect(tearX,0,2,WORLD_H);
        ctx.globalAlpha = 1;
      }
      ctx.globalAlpha = 0.08;
      for(let i=0;i<4;i++){
        const bx = Math.random()*WORLD_W;
        const bw = 1 + Math.random()*2;
        ctx.fillStyle = 'rgba(240,240,240,0.35)';
        ctx.fillRect(bx, Math.random()*WORLD_H, bw, 1);
      }
      ctx.globalAlpha = 1;
    }

    if(spec.key==='collapse'){
      ctx.globalAlpha = 0.24;
      const staticCount = Math.max(160, Math.floor(WORLD_W*WORLD_H/1400));
      const baseShift = ((this.levelTicks||0) * 0.12) + (this.staticSeed || 0);
      for(let i=0;i<staticCount;i++){
        ctx.fillStyle = (Math.random()<0.5) ? (pal.static || '#d4d4d4') : 'rgba(20,20,20,0.45)';
        const px=(Math.random()*WORLD_W + baseShift) % WORLD_W;
        const py=(Math.random()*WORLD_H + baseShift*0.7) % WORLD_H;
        const pw = (Math.random()<0.2)?2:1;
        ctx.fillRect(px,py,pw,1);
      }
      ctx.globalAlpha = 1;
    }

    if(jitterApplied) ctx.restore();
    ctx.restore();
  }

  drawChar(ch,x,y,fg){
    const spec=LEVELS[this.levelIndex]; const pal=PALETTES[spec.key];
    this.ctx.fillStyle=this.themedColor(fg,pal);
    let glyph=ch;
    const corruptBoost=(this.glitchT>0?0.25:0);
    let corruptChance=(100-this.sanity)/100*0.08+corruptBoost;
    if(spec.key==='paranoia'){ corruptChance+=0.05; }
    if(spec.key==='collapse'){ corruptChance+=0.22; }
    const roll=Math.random();
    if(roll<corruptChance){
      if(spec.key==='collapse' && ch!=='>' && ch!=='@'){
        glyph=choice(['#','%','&','*','@','/','\\','+']);
      } else {
        glyph=choice(['~','^','?','!','@','#','/','|']);
      }
    }
    this.ctx.fillText(glyph,x,y);
  }
  drawCharExact(ch,x,y,fg){
    const spec=LEVELS[this.levelIndex]; const pal=PALETTES[spec.key];
    this.ctx.fillStyle=this.themedColor(fg,pal);
    this.ctx.fillText(ch,x,y);
  }
  tintColor(color,t){
    const r=parseInt(color.slice(1,3),16), g=parseInt(color.slice(3,5),16), b=parseInt(color.slice(5,7),16);
    const tt = Array.isArray(t) ? t : [1,1,1];
    const nr=clamp(Math.round(r*(tt[0]!==undefined?tt[0]:1)),0,255);
    const ng=clamp(Math.round(g*(tt[1]!==undefined?tt[1]:1)),0,255);
    const nb=clamp(Math.round(b*(tt[2]!==undefined?tt[2]:1)),0,255);
    return `#${nr.toString(16).padStart(2,'0')}${ng.toString(16).padStart(2,'0')}${nb.toString(16).padStart(2,'0')}`;
  }
  themedColor(color,pal){
    let tinted=this.tintColor(color,pal.tint || [1,1,1]);
    if(pal.mode==='bw'){
      const r=parseInt(tinted.slice(1,3),16), g=parseInt(tinted.slice(3,5),16), b=parseInt(tinted.slice(5,7),16);
      const grey=Math.round(r*0.299+g*0.587+b*0.114);
      if(this.sanity<55 && Math.random()<0.05){ return '#aa1a1a'; }
      const hex=grey.toString(16).padStart(2,'0');
      tinted=`#${hex}${hex}${hex}`;
    }
    return tinted;
  }
  updateHUD(){
    document.getElementById('sanityBar').style.width=`${this.sanity}%`;
    document.getElementById('sanityPct').textContent=`${this.sanity|0}%`;
    const spec=LEVELS[this.levelIndex];
    const diamondTotal = this.diamondGoal ?? spec.diamonds;
    const diamondCollected = Math.max(0, diamondTotal - this.diamonds.size);
    document.getElementById('diamonds').textContent = `${diamondCollected}/${diamondTotal}`;
    document.getElementById('exitState').textContent=this.diamonds.size===0? 'Unlocked' : 'Locked';
  }

  loop(ts){
    const dt = this.last ? (ts - this.last) : 16;
    this.last = ts;
    this.levelTicks += dt;

    if(this.state==='melting'){ this.renderMelt(dt); requestAnimationFrame(this.loop.bind(this)); return; }
    if(this.state==='gameover'){ this.renderGameOver(); requestAnimationFrame(this.loop.bind(this)); return; }

    this.sanity=clamp(this.sanity-(SANITY_DRAIN_PS*this.sanityMul*dt/1000),0,100);
    if(this.sanity<=0){
      log('SANITY COLLAPSE. Melting…');
      this.startMelt();
      this.updateHUD();
      this.render();
      requestAnimationFrame(this.loop.bind(this));
      return;
    }

    if(LEVELS[this.levelIndex].key==='psychosis'){
      if(this.controlInvertT<=0 && this.sanity<60 && Math.random()<0.010){ this.controlInvertT = 180; }
      if(this.controlInvertT>0){ this.controlInvertT--; }
    }

    if(ts-this.lastMove>=MOVE_COOLDOWN){ this.tryMovePlayer(); this.lastMove=ts; }
    if(this.keys.has(' ')){ if(ts-this.lastShot>=BULLET_COOLDOWN){ this.shoot(); this.lastShot=ts; } }
    if(ts-this.lastEnemy>=this.enemyInterval){ this.updateEnemies(); this.lastEnemy=ts; }

    this.updateBullets(dt);

    if(LEVELS[this.levelIndex].key==='collapse'){
      this.collapseTimer -= dt;
      if(this.collapseTimer<=0){
        this.crumbleOne();
        const next = Math.max(450, 900 - Math.min(400, (this.trail.length*2)));
        this.collapseTimer = next;
      }
      if(this.extractionCountdown!==null){
        this.extractionCountdown -= dt;
        if(this.extractionCountdown<=0){
          log('Extraction window missed.');
          this.startMelt();
        }
      }
    }

    const pidx = this.player.y * this.map.w + this.player.x;
    if (!this.transitioning && this.diamonds.size === 0 && pidx === this.exit) {
      this.transitioning = true;
      const next = this.levelIndex + 1;
      if(next >= LEVELS.length){
        log('Extraction complete. Exiting.');
        setTimeout(() => { window.location.href = 'endgame.html'; }, 350);
      } else {
        log('Extraction point reached. Descending.');
        setTimeout(() => {
          this.levelIndex = next;
          this.resetLevel();
          this.transitioning = false;
        }, 0);
      }
      requestAnimationFrame(this.loop.bind(this));
      return;
    }

    this.updateHUD();
    this.render();
    requestAnimationFrame(this.loop.bind(this));
  }
}

/**********************
 * BOOT & API
 **********************/
buildSprites();                 // build procedural sprites first
const game=new Game();
window.Kommando={
  setPalette(key){
    const idx=LEVELS.findIndex(l=>l.key===key);
    if(idx>=0){ game.levelIndex=idx; game.resetLevel(); }
  }
};

/**********************
 * SELF-TESTS (safe)
 **********************/
(function runTests(){
  try{
    console.assert(typeof wallGlyph==='function','wallGlyph should be defined');
    const m=new Map(60,30); m.generate(12345, { rooms:12, connectors:3, carveSeeds:2, carveStepMul:1.3 });
    const walls=m.cells.filter(c=>c===1).length, floors=m.cells.length-walls;
    console.assert(walls>0 && floors>0,'Map should have walls and floors');
    const w=m.w,h=m.h; const seen=new Set(); let biggest=0;
    for(let y=1;y<h-1;y++) for(let x=1;x<w-1;x++){
      if(!m.isWall(x,y) && !seen.has(y*w+x)){
        let area=0; const q=[[x,y]]; seen.add(y*w+x);
        while(q.length){
          const [cx,cy]=q.pop(); area++;
          for(const [dx,dy] of [[1,0],[-1,0],[0,1],[0,-1]]){
            const nx=cx+dx, ny=cy+dy, id=ny*w+nx;
            if(nx>0&&ny>0&&nx<w-1&&ny<h-1 && !m.isWall(nx,ny) && !seen.has(id)){
              seen.add(id); q.push([nx,ny]);
            }
          }
        }
        biggest=Math.max(biggest,area);
      }
    }
    console.assert(biggest> (w*h*0.20), 'Largest cavern should be reasonably sized');
    const vis=computeFOV({w:60,h:30,isWall:(x,y)=>false}, 30,15,6); console.assert(vis.size>1,'FOV should return multiple visible tiles');
    console.assert(Array.isArray(ASCII_RIP) && ASCII_RIP.length>3, 'ASCII skull loaded');
    console.log('TEST OK');
  }catch(err){
    console.error(err); console.log('TEST FAIL:', err && err.message ? err.message : err);
  }
})();
</script>
</body>
</html>
